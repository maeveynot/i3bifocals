#!/usr/bin/python3

import sys
import json
import asyncio
from i3ipc.aio import Connection
from i3ipc import Event


class i3Bifocals:
    def __init__(self):
        self.status_blocks = []
        self.focused_name = None

    def print_blocks(self):
        focus_block = {
            "name": "focused_con",
            "full_text": self.focused_name or "-",
        }
        blocks = [focus_block, *self.status_blocks]
        print(json.dumps(blocks, ensure_ascii=False) + ",", flush=True)

    def handle_workspace_event(self, i3, event):
        if event.current.find_focused() is None:
            self.focused_name = None
            self.print_blocks()

    def handle_window_event(self, i3, event):
        if event.change == "focus" or event.change == "title" and event.container.focused:
            self.focused_name = event.container.name
            self.print_blocks()
        elif event.change == "close":
            self.focused_name = None
            self.print_blocks()

    async def subscribe_i3_events(self):
        i3 = await Connection().connect()

        i3.on(Event.WORKSPACE_FOCUS, self.handle_workspace_event)
        for event_type in (Event.WINDOW_FOCUS, Event.WINDOW_TITLE, Event.WINDOW_CLOSE):
            i3.on(event_type, self.handle_window_event)

        tree = await i3.get_tree()
        focused = tree.find_focused()
        if focused.type == "con":
            self.focused_name = focused.name
        else:
            self.focused_name = None

    async def exec_status_prog(self, argv):
        status_prog = await asyncio.create_subprocess_exec(*argv, stdout=asyncio.subprocess.PIPE)

        # our input and output must start with two very specific things (see
        # https://i3wm.org/docs/i3bar-protocol.html). verify that the status
        # program sent the same header to us.

        print(json.dumps({"version": 1}, indent=None))
        print("[")

        try:
            header = json.loads(await status_prog.stdout.readline())
        except (json.decoder.JSONDecodeError, ValueError):
            print(f"could not parse JSON header from {argv[0]}! exiting.", file=sys.stderr)
            sys.exit(1)

        if header["version"] != 1:
            print("got an unknown i3bar protocol version! exiting.", file=sys.stderr)
            sys.exit(1)

        array_start = await status_prog.stdout.read(1)
        if array_start != b"[":
            print(f"did not read a body from {argv[0]}! exiting.", file=sys.stderr)
            sys.exit(1)

        # read until we have a full array (which we know ends with a close
        # bracket). it is very unlikely we'll need to do multiple reads between
        # clearing the buffer, since i3status prints one array per line, but if
        # some other compatible program outputs pretty-printed JSON it's possible.

        buf = bytearray()
        while status_prog.returncode is None:
            buf += await status_prog.stdout.readuntil(b"]")
            try:
                s = buf.decode("utf-8").strip("\n,")
                self.status_blocks = json.loads(s)
                self.print_blocks()
                buf.clear()
            except json.decoder.JSONDecodeError:
                pass


async def gather(*tasks):
    return await asyncio.gather(*tasks)


if __name__ == "__main__":
    status_argv = sys.argv[1:] or ["i3status"]
    try:
        bf = i3Bifocals()
        watcher = bf.subscribe_i3_events()
        runner = bf.exec_status_prog(status_argv)
        asyncio.run(gather(watcher, runner))
    except (KeyboardInterrupt, SystemExit):
        sys.exit(0)
